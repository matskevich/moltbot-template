#!/bin/bash
# basic security pentest — verify your openclaw instance is hardened
#
# tests bwrap sandbox, fs-guard, vault, and settings integration
# runs locally against hooks in your workspace
#
# usage: ./scripts/pentest-basic.sh [hooks_dir]
# example: ./scripts/pentest-basic.sh ~/workspace/hooks

set -euo pipefail

BOLD='\033[1m'
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

PASS=0
FAIL=0
SKIP=0

test_pass() {
  echo -e "  ${GREEN}PASS${NC} $1"
  ((PASS++))
}

test_fail() {
  echo -e "  ${RED}FAIL${NC} $1 (got: $2, expected: $3)"
  ((FAIL++))
}

test_skip() {
  echo -e "  ${YELLOW}SKIP${NC} $1 — $2"
  ((SKIP++))
}

# hooks directory
HOOKS_DIR="${1:-./hooks}"

if [ ! -d "$HOOKS_DIR" ]; then
  echo -e "${RED}hooks directory not found: $HOOKS_DIR${NC}"
  echo "usage: $0 [hooks_dir]"
  exit 1
fi

echo -e "${BOLD}=== openclaw security pentest ===${NC}"
echo ""

# ============================================
# 1. BWRAP SANDBOX
# ============================================
echo -e "${BOLD}--- bwrap sandbox ---${NC}"

if command -v bwrap &>/dev/null; then
  test_pass "bwrap installed"

  # test: bwrap hides .openclaw
  BWRAP_TEST=$(bwrap --ro-bind /usr /usr --ro-bind /bin /bin --tmpfs "$HOME/.openclaw" \
    --proc /proc --dev /dev --tmpfs /tmp --die-with-parent \
    -- cat "$HOME/.openclaw/.env" 2>&1 | head -1 || true)
  if echo "$BWRAP_TEST" | grep -q "No such file"; then
    test_pass "bwrap hides .openclaw/.env"
  else
    test_fail "bwrap hides .openclaw/.env" "visible" "hidden"
  fi

  # test: bwrap hides .ssh
  BWRAP_SSH=$(bwrap --ro-bind /usr /usr --ro-bind /bin /bin --tmpfs "$HOME/.ssh" \
    --proc /proc --dev /dev --tmpfs /tmp --die-with-parent \
    -- ls "$HOME/.ssh/" 2>&1 | head -1 || true)
  if echo "$BWRAP_SSH" | grep -qi "No such file\|cannot access" || [ -z "$(echo "$BWRAP_SSH" | tr -d '[:space:]')" ]; then
    test_pass "bwrap hides .ssh"
  else
    test_fail "bwrap hides .ssh" "visible" "hidden"
  fi
else
  test_fail "bwrap installed" "no" "yes"
  test_skip "bwrap hide tests" "bwrap not installed"
fi

# test hook exists
SANDBOX_HOOK="$HOOKS_DIR/sandbox-exec/hook.sh"
if [ -x "$SANDBOX_HOOK" ]; then
  test_pass "sandbox-exec hook exists and executable"

  # test: hook wraps command in bwrap
  HOOK_OUT=$(echo '{"tool_name":"Bash","tool_input":{"command":"echo test"}}' | "$SANDBOX_HOOK" 2>/dev/null || true)
  WRAPPED=$(echo "$HOOK_OUT" | jq -r '.hookSpecificOutput.updatedInput.command // "none"' 2>/dev/null || echo "none")
  if echo "$WRAPPED" | grep -q "bwrap"; then
    test_pass "hook wraps Bash in bwrap"
  else
    test_fail "hook wraps Bash in bwrap" "not wrapped" "wrapped"
  fi

  # test: hook denies sudo
  HOOK_SUDO=$(echo '{"tool_name":"Bash","tool_input":{"command":"sudo cat /etc/shadow"}}' | "$SANDBOX_HOOK" 2>/dev/null || true)
  DECISION=$(echo "$HOOK_SUDO" | jq -r '.hookSpecificOutput.permissionDecision // "none"' 2>/dev/null || echo "none")
  if [ "$DECISION" = "deny" ]; then
    test_pass "hook denies sudo"
  else
    test_fail "hook denies sudo" "$DECISION" "deny"
  fi
else
  test_fail "sandbox-exec hook exists" "missing" "present"
fi

echo ""

# ============================================
# 2. FS-GUARD
# ============================================
echo -e "${BOLD}--- fs-guard ---${NC}"

FS_HOOK="$HOOKS_DIR/fs-guard/hook.sh"
if [ -x "$FS_HOOK" ]; then
  test_pass "fs-guard hook exists and executable"

  # test: block .env read
  FS_DENY=$(echo '{"tool_name":"Read","tool_input":{"file_path":"'"$HOME/.openclaw/.env"'"}}' | "$FS_HOOK" 2>/dev/null || true)
  FS_D=$(echo "$FS_DENY" | jq -r '.hookSpecificOutput.permissionDecision // "none"' 2>/dev/null || echo "none")
  if [ "$FS_D" = "deny" ]; then
    test_pass "fs-guard blocks Read .env"
  else
    test_fail "fs-guard blocks Read .env" "$FS_D" "deny"
  fi

  # test: block /etc read
  FS_ETC=$(echo '{"tool_name":"Read","tool_input":{"file_path":"/etc/passwd"}}' | "$FS_HOOK" 2>/dev/null || true)
  FS_E=$(echo "$FS_ETC" | jq -r '.hookSpecificOutput.permissionDecision // "none"' 2>/dev/null || echo "none")
  if [ "$FS_E" = "deny" ]; then
    test_pass "fs-guard blocks Read /etc"
  else
    test_fail "fs-guard blocks Read /etc" "$FS_E" "deny"
  fi

  # test: block path traversal
  FS_TRAV=$(echo '{"tool_name":"Read","tool_input":{"file_path":"'"$HOME/workspace/../../.ssh/id_rsa"'"}}' | "$FS_HOOK" 2>/dev/null || true)
  FS_T=$(echo "$FS_TRAV" | jq -r '.hookSpecificOutput.permissionDecision // "none"' 2>/dev/null || echo "none")
  if [ "$FS_T" = "deny" ]; then
    test_pass "fs-guard blocks path traversal"
  else
    test_fail "fs-guard blocks path traversal" "$FS_T" "deny"
  fi

  # test: allow /tmp
  FS_TMP=$(echo '{"tool_name":"Write","tool_input":{"file_path":"/tmp/test.txt"}}' | "$FS_HOOK" 2>/dev/null || true)
  if [ -z "$FS_TMP" ]; then
    test_pass "fs-guard allows /tmp"
  else
    FS_TMP_D=$(echo "$FS_TMP" | jq -r '.hookSpecificOutput.permissionDecision // "allow"' 2>/dev/null || echo "allow")
    if [ "$FS_TMP_D" = "deny" ]; then
      test_fail "fs-guard allows /tmp" "blocked" "allowed"
    else
      test_pass "fs-guard allows /tmp"
    fi
  fi

  # test: block Edit on config
  FS_CFG=$(echo '{"tool_name":"Edit","tool_input":{"file_path":"'"$HOME/.openclaw/openclaw.json"'"}}' | "$FS_HOOK" 2>/dev/null || true)
  FS_C=$(echo "$FS_CFG" | jq -r '.hookSpecificOutput.permissionDecision // "none"' 2>/dev/null || echo "none")
  if [ "$FS_C" = "deny" ]; then
    test_pass "fs-guard blocks Edit config"
  else
    test_fail "fs-guard blocks Edit config" "$FS_C" "deny"
  fi

  # test: block Grep on home
  FS_GREP=$(echo '{"tool_name":"Grep","tool_input":{"pattern":"API_KEY","path":"'"$HOME"'"}}' | "$FS_HOOK" 2>/dev/null || true)
  FS_G=$(echo "$FS_GREP" | jq -r '.hookSpecificOutput.permissionDecision // "none"' 2>/dev/null || echo "none")
  if [ "$FS_G" = "deny" ]; then
    test_pass "fs-guard blocks Grep on home"
  else
    test_fail "fs-guard blocks Grep on home" "$FS_G" "deny"
  fi
else
  test_fail "fs-guard hook exists" "missing" "present"
fi

echo ""

# ============================================
# 3. VAULT (optional checks)
# ============================================
echo -e "${BOLD}--- vault ---${NC}"

if [ -f "$HOME/.openclaw/.env" ]; then
  test_fail "plaintext .env removed" "still exists" "removed"
  echo -e "  ${YELLOW}→ run scripts/setup-vault.sh to encrypt .env${NC}"
else
  test_pass "plaintext .env removed (or never existed)"
fi

if command -v sops &>/dev/null; then
  test_pass "sops installed"
else
  test_skip "sops installed" "vault not configured"
fi

if command -v age &>/dev/null; then
  test_pass "age installed"
else
  test_skip "age installed" "vault not configured"
fi

echo ""

# ============================================
# 4. OUTPUT DLP
# ============================================
echo -e "${BOLD}--- output DLP ---${NC}"

DLP_HOOK="$HOOKS_DIR/output-filter/handler.ts"
if [ -f "$DLP_HOOK" ]; then
  test_pass "output-filter DLP hook exists"
else
  test_skip "output-filter DLP hook" "not installed"
fi

echo ""

# ============================================
# 5. SETTINGS INTEGRATION
# ============================================
echo -e "${BOLD}--- settings.json ---${NC}"

SETTINGS="$HOME/.openclaw/settings.json"
if [ -f "$SETTINGS" ]; then
  test_pass "settings.json exists"

  HAS_SANDBOX=$(jq -e '.hooks.PreToolUse[]? | select(.matcher == "Bash")' "$SETTINGS" &>/dev/null && echo yes || echo no)
  if [ "$HAS_SANDBOX" = "yes" ]; then
    test_pass "sandbox-exec hook registered for Bash"
  else
    test_fail "sandbox-exec hook registered" "no" "yes"
  fi

  HAS_FSGUARD=$(jq -e '.hooks.PreToolUse[]? | select(.matcher | test("Read"))' "$SETTINGS" &>/dev/null && echo yes || echo no)
  if [ "$HAS_FSGUARD" = "yes" ]; then
    test_pass "fs-guard hook registered for Read"
  else
    test_fail "fs-guard hook registered" "no" "yes"
  fi
else
  test_skip "settings.json checks" "no settings.json found"
fi

echo ""

# ============================================
# SUMMARY
# ============================================
TOTAL=$((PASS + FAIL + SKIP))
echo -e "${BOLD}=== results: ${GREEN}${PASS} pass${NC} / ${RED}${FAIL} fail${NC} / ${YELLOW}${SKIP} skip${NC} (${TOTAL} total) ===${NC}"
echo ""

if [ $FAIL -gt 0 ]; then
  echo -e "${YELLOW}fix the FAILed checks above, then re-run this script.${NC}"
  exit 1
else
  echo -e "${GREEN}all checks passed.${NC}"
fi
